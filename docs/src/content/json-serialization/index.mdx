import { Callout } from "nextra/components";

# JSON Serialization Overview

CodableJSON provides high-performance JSON serialization that extends standard JSON to handle JavaScript types that JSON can't serialize natively.

## Quick Start

```typescript
import { encode, decode } from "codablejson";

const data = {
  date: new Date("2025-01-01"),
  set: new Set(["a", "b", "c"]),
  map: new Map([["key", "value"]]),
};

const encoded = encode(data);
// Result: {
//   date: { $$Date: "2025-01-01T00:00:00.000Z" },
//   set: { $$Set: ["a", "b", "c"] },
//   map: { $$Map: [["key", "value"]] }
// }

const decoded = decode(encoded);
// decoded.date instanceof Date === true
```

[Open playground](https://codablejson.com/playground/) to test your own data.

## Key Features

- **Serializes JavaScript types**: `Date`, `BigInt`, `Map`, `Set`, `RegExp`, `Symbol`, `Error`, `URL`, typed arrays, and more
- **Human-readable output**: Uses tagged format that's still readable and debuggable
- **Great performance**: ~3x faster encoding and ~2x faster decoding than SuperJSON
- **Reference preservation**: Handles circular references and maintains object identity
- **Type safety**: Full TypeScript support with autocompletion

## Stringify & Parse

For convenience, CodableJSON provides `stringify` and `parse` functions that combine encoding/decoding with JSON stringification:

```typescript
import { stringify, parse } from "codablejson";

const jsonString = stringify(data);
const restored = parse(jsonString);
```

## Try It Out

Experiment with CodableJSON in the [playground](https://codablejson.com/playground/) to see how different types are encoded and test circular reference handling.
